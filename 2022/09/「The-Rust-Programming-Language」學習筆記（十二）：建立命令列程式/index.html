<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta name="author" content="Memo Chou">
    <meta name="description" content="Memo's Blog">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="前言本文為「The Rust Programming Language」語言指南的學習筆記。 簡介Rust 的速度、安全、單一二進制輸出與跨平台支援使其成為建立命令列工具的絕佳語言。所以在我們的專案中，我們要寫出我們自己的經典命令列工具 grep（globally search a regular expression and print）。在最簡單的使用場合中，grep 會搜尋指定檔案中的指定字">
<meta property="og:type" content="article">
<meta property="og:title" content="「The Rust Programming Language」學習筆記（十二）：建立命令列程式">
<meta property="og:url" content="https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/index.html">
<meta property="og:site_name" content="Memo&#39;s Blog">
<meta property="og:description" content="前言本文為「The Rust Programming Language」語言指南的學習筆記。 簡介Rust 的速度、安全、單一二進制輸出與跨平台支援使其成為建立命令列工具的絕佳語言。所以在我們的專案中，我們要寫出我們自己的經典命令列工具 grep（globally search a regular expression and print）。在最簡單的使用場合中，grep 會搜尋指定檔案中的指定字">
<meta property="og:locale">
<meta property="article:published_time" content="2022-09-24T06:06:20.000Z">
<meta property="article:modified_time" content="2023-11-30T03:05:47.735Z">
<meta property="article:author" content="Memo Chou">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>「The Rust Programming Language」學習筆記（十二）：建立命令列程式</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&family=Raleway:wght@900&display=swap" rel="stylesheet">
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Memo's Blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        
          
            <li><a href="/">Home</a></li>
          
        
          
            <li><a href="/archives">Archives</a></li>
          
        
          
        
          
        
          
            <li><a href="/search">Search</a></li>
          
        
          
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E6%B8%AC%E8%A9%A6/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/09/%E4%BD%BF%E7%94%A8-Yew-%E5%92%8C-WebAssembly-%E5%AF%A6%E4%BD%9C%E3%80%8C%E8%A6%96%E8%A8%8A%E4%B8%B2%E6%B5%81%E3%80%8D%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <!-- <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li> -->
      </ul>
      <!-- <span id="i-next" class="info" style="display:none;"></span>
      <span id="i-prev" class="info" style="display:none;"></span>
      <span id="i-top" class="info" style="display:none;"></span>
      <span id="i-share" class="info" style="display:none;"></span> -->
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&text=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&is_video=false&description=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=「The Rust Programming Language」學習筆記（十二）：建立命令列程式&body=Check out this article: https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&name=「The Rust Programming Language」學習筆記（十二）：建立命令列程式&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%A1%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">簡介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E5%91%BD%E4%BB%A4%E5%88%97%E5%BC%95%E6%95%B8"><span class="toc-number">3.</span> <span class="toc-text">接受命令列引數</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E5%BC%95%E6%95%B8%E6%95%B8%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">讀取引數數值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E5%BC%95%E6%95%B8%E6%95%B8%E5%80%BC%E5%84%B2%E5%AD%98%E8%87%B3%E8%AE%8A%E6%95%B8"><span class="toc-number">3.2.</span> <span class="toc-text">將引數數值儲存至變數</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E6%AA%94%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">讀取檔案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%A7%8B"><span class="toc-number">5.</span> <span class="toc-text">重構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%96%8B%E4%BA%8C%E9%80%B2%E5%88%B6%E5%B0%88%E6%A1%88%E7%9A%84%E4%BB%BB%E5%8B%99"><span class="toc-number">5.1.</span> <span class="toc-text">分開二進制專案的任務</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%BC%95%E6%95%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">提取引數解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%B5%90%E9%85%8D%E7%BD%AE%E6%95%B8%E5%80%BC"><span class="toc-number">5.1.2.</span> <span class="toc-text">集結配置數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-Config-%E7%9A%84%E5%BB%BA%E6%A7%8B%E5%AD%90"><span class="toc-number">5.1.3.</span> <span class="toc-text">建立 Config 的建構子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">修正錯誤處理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">改善錯誤訊息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%82%B3-Result-%E8%80%8C%E9%9D%9E%E6%81%90%E6%85%8C"><span class="toc-number">5.2.2.</span> <span class="toc-text">回傳 Result 而非恐慌</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BC%E5%8F%AB-Config-new-%E4%B8%A6%E8%99%95%E7%90%86%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.2.3.</span> <span class="toc-text">呼叫 Config::new 並處理錯誤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-main-%E9%82%8F%E8%BC%AF"><span class="toc-number">5.3.</span> <span class="toc-text">提取 main 邏輯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%9E-run-%E5%87%BD%E5%BC%8F%E5%9B%9E%E5%82%B3%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.4.</span> <span class="toc-text">從 run 函式回傳錯誤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%95%E7%90%86-run-%E5%9B%9E%E5%82%B3%E7%9A%84%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.4.1.</span> <span class="toc-text">處理 run 回傳的錯誤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%8B%86%E5%88%B0%E5%87%BD%E5%BC%8F%E5%BA%AB-Crate"><span class="toc-number">5.5.</span> <span class="toc-text">將程式碼拆到函式庫 Crate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">完善功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%A8%E5%AF%AB%E5%A4%B1%E6%95%97%E7%9A%84%E6%B8%AC%E8%A9%A6"><span class="toc-number">6.1.</span> <span class="toc-text">編寫失敗的測試</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%AB%E5%87%BA%E8%AE%93%E6%B8%AC%E8%A9%A6%E6%88%90%E5%8A%9F%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="toc-number">6.2.</span> <span class="toc-text">寫出讓測試成功的程式碼</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E9%81%8E-lines-%E6%96%B9%E6%B3%95%E4%BE%86%E9%81%8D%E6%AD%B7%E6%AF%8F%E4%B8%80%E8%A1%8C"><span class="toc-number">6.2.1.</span> <span class="toc-text">透過 lines 方法來遍歷每一行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AA%A2%E6%9F%A5%E6%AF%8F%E8%A1%8C%E6%98%AF%E5%90%A6%E6%9C%89%E8%A6%81%E6%90%9C%E5%B0%8B%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="toc-number">6.2.2.</span> <span class="toc-text">檢查每行是否有要搜尋的字串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%84%B2%E5%AD%98%E7%AC%A6%E5%90%88%E6%A2%9D%E4%BB%B6%E7%9A%84%E8%A1%8C"><span class="toc-number">6.2.3.</span> <span class="toc-text">儲存符合條件的行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-run-%E5%87%BD%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-search-%E5%87%BD%E5%BC%8F"><span class="toc-number">6.2.4.</span> <span class="toc-text">在 run 函式中使用 search 函式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%95%E7%90%86%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8"><span class="toc-number">7.</span> <span class="toc-text">處理環境變數</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%AB%E5%80%8B%E4%B8%8D%E5%8D%80%E5%88%86%E5%A4%A7%E5%B0%8F%E5%AF%AB%E7%9A%84-search-%E5%87%BD%E5%BC%8F%E7%9A%84%E5%A4%B1%E6%95%97%E6%B8%AC%E8%A9%A6"><span class="toc-number">7.1.</span> <span class="toc-text">寫個不區分大小寫的 search 函式的失敗測試</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%A6%E4%BD%9C-search-case-insensitive-%E5%87%BD%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">實作 search_case_insensitive 函式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%95%E7%90%86%E6%A8%99%E6%BA%96%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.</span> <span class="toc-text">處理標準錯誤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AA%A2%E6%9F%A5%E8%A9%B2%E5%9C%A8%E5%93%AA%E8%A3%A1%E5%AF%AB%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.1.</span> <span class="toc-text">檢查該在哪裡寫錯誤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E9%8C%AF%E8%AA%A4%E5%8D%B0%E5%87%BA%E8%87%B3%E6%A8%99%E6%BA%96%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.2.</span> <span class="toc-text">將錯誤印出至標準錯誤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="toc-number">9.</span> <span class="toc-text">程式碼</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="toc-number">10.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post my2" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        「The Rust Programming Language」學習筆記（十二）：建立命令列程式
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">
          <a href="/">
          Memo's Blog
          </a>
        </span>
      </span>
      
    <div class="postdate">
        <time datetime="2022-09-24T06:06:20.000Z" itemprop="datePublished">2022-09-24</time>
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        
            
        
            
        
            
                <a href="/categories/Programming/Rust/%E3%80%8CThe-Rust-Programming-Language%E3%80%8DStudy-Notes/">「The Rust Programming Language」Study Notes</a>
            
        
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Programming/" rel="tag">Programming</a>, <a class="tag-link-link" href="/tags/Rust/" rel="tag">Rust</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文為「<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a>」語言指南的學習筆記。</p>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>Rust 的速度、安全、單一二進制輸出與跨平台支援使其成為建立命令列工具的絕佳語言。所以在我們的專案中，我們要寫出我們自己的經典命令列工具 <code>grep</code>（globally search a regular expression and print）。在最簡單的使用場合中，<code>grep</code> 會搜尋指定檔案中的指定字串。為此 <code>grep</code> 會接收一個檔案名稱與一個字串作為其引數。然後它會讀取檔案、在該檔案中找到包含字串引數的行，並印出這些行。</p>
<p>在過程中，我們會展示如何讓我們的命令列工具和其他許多命令列工具一樣使用終端機的功能。我們會讀取一個環境變數的數值來讓使用者可以配置此工具的行為。我們還會將錯誤訊息在控制台中的標準錯誤（stderr）顯示而非標準輸出（stdout）。所以舉例來說，使用者可以將成功的標準輸出重新導向至一個檔案，並仍能在螢幕上看到錯誤訊息。</p>
<h2 id="接受命令列引數"><a href="#接受命令列引數" class="headerlink" title="接受命令列引數"></a>接受命令列引數</h2><p>建立專案。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new minigrep</span><br><span class="line"><span class="built_in">cd</span> minigrep</span><br></pre></td></tr></table></figure>

<p>第一項任務是要讓 <code>minigrep</code> 能接收兩個命令列引數：檔案名稱與欲搜尋的字串。如以下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run searchstring example-filename.txt</span><br></pre></td></tr></table></figure>

<h3 id="讀取引數數值"><a href="#讀取引數數值" class="headerlink" title="讀取引數數值"></a>讀取引數數值</h3><p>要讓 <code>minigrep</code> 能夠讀取傳入的命令列引數數值，需要使用 Rust 標準函式庫中提供的函式，也就是 <code>std::env::args</code>。此函式會回傳一個包含我們傳給 <code>minigrep</code> 的命令列引數的疊代器（iterator）。現在只需要知道疊代器的兩項重點：疊代器會產生一系列的數值，然後我們可以對疊代器呼叫 <code>collect</code> 方法來將其轉換成像是向量的集合，來包含疊代器產生的所有元素。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我們要用的函式模組路徑超過一層以上的話，通常就會將上層模組引入作用域中，而不是函式本身。這樣的話，我們可以輕鬆使用 <code>std::env</code> 中的其他函式。</p>
<p>我們在 <code>main</code> 中的第一行呼叫 <code>env::args</code>，然後馬上使用 <code>collect</code> 來將疊代器轉換成向量，這會包含疊代器產生的所有數值。我們可以使用 <code>collect</code> 函式來建立許多種集合，所以我們顯式詮釋 <code>args</code> 的型別來指定我們想要字串向量。雖然我們很少需要在 Rust 中詮釋型別，<code>collect</code> 是其中一個你常常需要詮釋的函式，因為 Rust 無法推斷出你想要何種集合。</p>
<p>最後，我們使用除錯格式 <code>:?</code> 來顯示向量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run needle haystack</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.00s</span><br><span class="line">     Running `target/debug/minigrep needle haystack`</span><br><span class="line">[<span class="string">&quot;target/debug/minigrep&quot;</span>, <span class="string">&quot;needle&quot;</span>, <span class="string">&quot;haystack&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>值得注意的是向量中第一個數值為 <code>&quot;target/debug/minigrep&quot;</code>，這是我們的執行檔名稱。這與 C 的引數列表行為相符，讓程式在執行時能使用它們被呼叫的名稱路徑。</p>
<h3 id="將引數數值儲存至變數"><a href="#將引數數值儲存至變數" class="headerlink" title="將引數數值儲存至變數"></a>將引數數值儲存至變數</h3><p>顯示向量中的引數數值能說明程式能夠取得命令列引數指定的數值。現在我們想要將這兩個引數存入變數中。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜尋 &#123;&#125;&quot;</span>, query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們暫時印出這些變數的數值來證明程式碼運作無誤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo run <span class="built_in">test</span> sample.txt</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/minigrep <span class="built_in">test</span> sample.txt`</span><br><span class="line">搜尋 <span class="built_in">test</span></span><br><span class="line">目標檔案為 sample.txt</span><br></pre></td></tr></table></figure>

<h2 id="讀取檔案"><a href="#讀取檔案" class="headerlink" title="讀取檔案"></a>讀取檔案</h2><p>新增 <code>poem.txt</code> 檔。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m nobody! Who are you?</span><br><span class="line">Are you nobody, too?</span><br><span class="line">Then there&#x27;s a pair of us - don&#x27;t tell!</span><br><span class="line">They&#x27;d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>修改 <code>main.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;讀取檔案時發生了錯誤&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文字內容：\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們加上另一個 <code>use</code> 陳述式來將標準函式庫中的另一個相關部分引入：我們需要 <code>std::fs</code> 來處理檔案。</p>
<p>在 <code>main</code> 中，我們加上新的陳述式：<code>fs::read_to_string</code> 會接收 <code>filename</code>、開啟該檔案並回傳檔案內容的 <code>Result&lt;String&gt;</code>。</p>
<p>在陳述式之後，我們再次加上暫時的 <code>println!</code> 陳述式來在讀取檔案之後，顯示 <code>contents</code> 的數值，讓我們能檢查程式目前運作無誤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cargo run the poem.txt</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/minigrep the poem.txt`</span><br><span class="line">搜尋 the</span><br><span class="line">目標檔案為 poem.txt</span><br><span class="line">文字內容：</span><br><span class="line">I<span class="string">&#x27;m nobody! Who are you?</span></span><br><span class="line"><span class="string">Are you nobody, too?</span></span><br><span class="line"><span class="string">Then there&#x27;</span>s a pair of us - don<span class="string">&#x27;t tell!</span></span><br><span class="line"><span class="string">They&#x27;</span>d banish us, you know.</span><br><span class="line"></span><br><span class="line">How dreary to be somebody!</span><br><span class="line">How public, like a frog</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<h2 id="重構"><a href="#重構" class="headerlink" title="重構"></a>重構</h2><h3 id="分開二進制專案的任務"><a href="#分開二進制專案的任務" class="headerlink" title="分開二進制專案的任務"></a>分開二進制專案的任務</h3><p><code>main</code> 函式負責多數任務的組織分配問題在許多二進制專案中都很常見。所以 Rust 社群開發出了一種流程，這在當 <code>main</code> 開始變大時，能作為分開二進制程式中任務的指導原則。此流程有以下步驟：</p>
<ul>
<li>將你的程式分成 <code>main.rs</code> 與 <code>lib.rs</code> 並將程式邏輯放到 <code>lib.rs</code>。</li>
<li>只要你的命令列解析邏輯很小，它可以留在 <code>main.rs</code>。</li>
<li>當命令行解析邏輯變得複雜時，就將其從 <code>main.rs</code> 移至 <code>lib.rs</code>。</li>
</ul>
<p>在此流程之後的 <code>main</code> 函式應該要只負責以下任務：</p>
<ul>
<li>透過引數數值呼叫命令列解析邏輯。</li>
<li>設置任何其他的配置。</li>
<li>呼叫 <code>lib.rs</code> 中的 <code>run</code> 函式。</li>
<li>如果 <code>run</code> 回傳錯誤的話，處理該錯誤。</li>
</ul>
<p>此模式用於分開不同任務：<code>main.rs</code> 處理程式的執行，然後 <code>lib.rs</code> 處理眼前的所有任務邏輯。因為你無法直接測試 <code>main</code>，此架構讓你能測試所有移至 <code>lib.rs</code> 的程式函式邏輯。留在 <code>main.rs</code> 的程式碼會非常小，所以容易直接用閱讀來驗證。</p>
<h4 id="提取引數解析器"><a href="#提取引數解析器" class="headerlink" title="提取引數解析器"></a>提取引數解析器</h4><p>新的 <code>main</code> 會呼叫新的函式 <code>parse_config</code>，而此函式我們先暫時留在 <code>src/main.rs</code>。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (query, filename) = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> (&amp;<span class="type">str</span>, &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    (query, filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集結配置數值"><a href="#集結配置數值" class="headerlink" title="集結配置數值"></a>集結配置數值</h4><p>我們定義一個結構體 <code>Config</code> 其欄位有 <code>query</code> 與 <code>filename</code>。但是 <code>main</code> 中的 <code>args</code> 變數是引數數值的擁有者，而且只是借用它們給 <code>parse_config</code> 函式，這意味著如果 <code>Config</code> 嘗試取得 <code>args</code> 中數值的所有權的話，會違反 Rust 的借用規則。</p>
<p>我們可以用許多不同的方式來管理 <code>String</code> 的資料，但最簡單（卻較不有效率）的方式是對數值呼叫 <code>clone</code> 方法。這會複製整個資料讓 <code>Config</code> 能夠擁有，這會比引用字串資料還要花時間與記憶體。然而克隆資料讓我們的程式碼比較直白，因為在此情況下我們就不需要管理引用的生命週期，犧牲一點效能以換取簡潔性是值得的。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = <span class="title function_ invoke__">parse_config</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜尋 &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;讀取檔案時發生了錯誤&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文字內容：\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    query: <span class="type">String</span>,</span><br><span class="line">    filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">parse_config</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    Config &#123; query, filename &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立-Config-的建構子"><a href="#建立-Config-的建構子" class="headerlink" title="建立 Config 的建構子"></a>建立 <code>Config</code> 的建構子</h4><p>現在 <code>parse_config</code> 函式的目的是要建立 <code>Config</code> 實例，我們可以將 <code>parse_config</code> 從普通的函式變成與 <code>Config</code> 結構體相關連的 <code>new</code> 函式。這樣做能讓程式碼更符合慣例。我們可以對像是 <code>String</code> 等標準函式庫中的型別呼叫 <code>String::new</code> 來建立實例。同樣地，透過將 <code>parse_config</code> 改為 <code>Config</code> 的關聯函式 <code>new</code>，我們可以透過呼叫 <code>Config::new</code> 來建立 <code>Config</code> 的實例。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        Config &#123; query, filename &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修正錯誤處理"><a href="#修正錯誤處理" class="headerlink" title="修正錯誤處理"></a>修正錯誤處理</h3><p>要是 <code>args</code> 向量中的項目太少的話，嘗試取得向量中索引 <code>1</code> 或索引 <code>2</code> 的數值的話可能就會導致程式恐慌。</p>
<h4 id="改善錯誤訊息"><a href="#改善錯誤訊息" class="headerlink" title="改善錯誤訊息"></a>改善錯誤訊息</h4><p>在 <code>new</code> 函式加上了一項檢查來驗證 <code>slice</code> 是否夠長，接著才會取得索引 <code>1</code> 和 <code>2</code>。如果 <code>slice</code> 不夠長的話，程式就會恐慌。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> Config &#123;</span><br><span class="line">    <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;引數不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回傳-Result-而非恐慌"><a href="#回傳-Result-而非恐慌" class="headerlink" title="回傳 Result 而非恐慌"></a>回傳 Result 而非恐慌</h4><p>我們可以回傳 <code>Result</code> 數值，在成功時包含 <code>Config</code> 的實例並在錯誤時描述問題原因。當 <code>Config::new</code> 與 <code>main</code> 溝通時，我們可以使用 <code>Result</code> 型別來表達這裡有問題發生。然後我們改變 <code>main</code> 來將 <code>Err</code> 變體轉換成適當的錯誤訊息給使用者，而不是像呼叫 <code>panic!</code> 時出現圍繞著 <code>thread &#39;main&#39;</code> 與 <code>RUST_BACKTRACE</code> 的文字。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;引數不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們的 <code>new</code> 函式現在會回傳 <code>Result</code>，在成功時會有 <code>Config</code> 實例，而在錯誤時會有個 <code>&amp;&#39;static str</code>。我們的錯誤值永遠會是有 <code>&#39;static</code> 生命週期的字串字面值。</p>
<p>我們在 <code>new</code> 函式本體作出了兩項改變：不同於呼叫 <code>panic!</code>，當使用者沒有傳遞足夠引數時，我們現在會回傳 <code>Err</code> 數值。此外我們也將 <code>Config</code> 封裝進 <code>Ok</code> 作為回傳值。這些改變讓函式能符合其新的型別簽名。</p>
<p>從 <code>Config::new</code> 回傳 <code>Err</code> 數值讓 <code>main</code> 函式能處理 <code>new</code> 函式回傳的 <code>Result</code> 數值，並明確地在錯誤情況下離開程序。</p>
<h4 id="呼叫-Config-new-並處理錯誤"><a href="#呼叫-Config-new-並處理錯誤" class="headerlink" title="呼叫 Config::new 並處理錯誤"></a>呼叫 <code>Config::new</code> 並處理錯誤</h4><p>為了能處理錯誤情形並印出對使用者友善的訊息，我們需要更新 <code>main</code> 來處理 <code>Config::new</code> 回傳的 <code>Result</code>。我們還要負責用一個非零的錯誤碼來離開命令列工具，這原先是 <code>panic!</code> 會處理的，現在我們得自己實作。非零退出狀態是個常見信號，用來告訴呼叫程式的程序，該程式離開時有個錯誤狀態。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;解析引數時出現問題：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 <code>unwrap_or_else</code>，這定義在標準函式庫的 <code>Result&lt;T, E&gt;</code> 中。使用 <code>unwrap_or_else</code> 讓我們能定義一些自訂的非 <code>panic!</code> 錯誤處理。如果 <code>Result</code> 數值為 <code>Ok</code>，此方法行為就類似於 <code>unwrap</code>，它會回傳 <code>Ok</code> 所封裝的內部數值。然而，如果數值為 <code>Err</code> 的話，此方法會呼叫閉包（closure）內的程式碼，這會是由我們所定義的匿名函式並作為引數傳給 <code>unwrap_or_else</code>。</p>
<p>還新增了一行 <code>use</code> 來將標準函式庫中的 <code>process</code> 引入作用域。在錯誤情形下要執行的閉包程式碼只有兩行：我們印出 <code>err</code> 數值並呼叫 <code>process::exit</code>。<code>process::exit</code> 函式會立即停止程式並回傳給予的數字來作為退出狀態碼。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.48s</span><br><span class="line">     Running `target/debug/minigrep`</span><br><span class="line">解析引數時出現問題：引數不足</span><br></pre></td></tr></table></figure>

<h3 id="提取-main-邏輯"><a href="#提取-main-邏輯" class="headerlink" title="提取 main 邏輯"></a>提取 main 邏輯</h3><p>修改 <code>src/main.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜尋 &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">run</span>(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;讀取檔案時發生了錯誤&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文字內容：\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="從-run-函式回傳錯誤"><a href="#從-run-函式回傳錯誤" class="headerlink" title="從 run 函式回傳錯誤"></a>從 run 函式回傳錯誤</h3><p>可以像 <code>Config::new</code> 一樣來改善錯誤處理。不同於讓程式呼叫 <code>expect</code> 來恐慌，當有問題發生時，<code>run</code> 函式會回傳 <code>Result&lt;T, E&gt;</code>。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文字內容：\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>對於錯誤型別，我們使用特徵物件（trait object）<code>Box&lt;dyn Error&gt;</code>（然後我們在最上方透過 <code>use</code> 陳述式來將 <code>std::error::Error</code> 引入作用域）。現在只需要知道 <code>Box&lt;dyn Error&gt;</code> 代表函式會回傳有實作 <code>Error</code> 特徵的型別，但我們不必指定回傳值的明確型別。這增加了回傳錯誤數值的彈性，其在不同錯誤情形中可能有不同的型別。<code>dyn</code> 關鍵字是「動態（dynamic）」的縮寫。</p>
<p>再來，我們移除了 <code>expect</code> 的呼叫並改為 <code>?</code> 運算子。所以與其對錯誤 <code>panic!</code>，<code>?</code> 運算子會回傳當前函式的錯誤數值，並交由呼叫者處理。</p>
<p>第三，<code>run</code> 函式現在成功時會回傳 <code>Ok</code> 數值。我們在 <code>run</code> 函式簽名中的成功型別為 <code>()</code>，這意味著我們需要將單元型別封裝進 <code>Ok</code> 數值。<code>Ok(())</code> 這樣的語法一開始看可能會覺得有點奇怪，但這樣子使用 <code>()</code> 的確符合慣例，說明我們呼叫 <code>run</code> 只是為了它的副作用，它不會回傳我們需要的數值。</p>
<h4 id="處理-run-回傳的錯誤"><a href="#處理-run-回傳的錯誤" class="headerlink" title="處理 run 回傳的錯誤"></a>處理 <code>run</code> 回傳的錯誤</h4><p>修改 <code>src/main.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜尋 &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = <span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;應用程式錯誤：&#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此使用 <code>if let</code> 而非 <code>unwrap_or_else</code> 來檢查 <code>run</code> 是否有回傳 <code>Err</code> 數值，並以此呼叫 <code>process::exit(1)</code>。<code>run</code> 函式沒有回傳數值，所以我們不必像處理 <code>Config::new</code> 得用 <code>unwrap</code> 取得 <code>Config</code> 實例。因為 <code>run</code> 在成功時會回傳 <code>()</code>，而我們只在乎偵測錯誤，所以我們不需要 <code>unwrap_or_else</code> 來回傳解封裝後的數值，因為它只會是 <code>()</code>。</p>
<p><code>if let</code> 的本體與 <code>unwrap_or_else</code> 函式則都做一樣的事情：印出錯誤並離開。</p>
<h3 id="將程式碼拆到函式庫-Crate"><a href="#將程式碼拆到函式庫-Crate" class="headerlink" title="將程式碼拆到函式庫 Crate"></a>將程式碼拆到函式庫 Crate</h3><p>新增 <code>src/lib.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;引數不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123; query, filename &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;文字內容：\n&#123;&#125;&quot;</span>, contents);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們對許多項目都使用了 <code>pub</code> 關鍵字，這包含 <code>Config</code> 與其欄位，以及其 <code>new</code> 方法，還有 <code>run</code> 函式。</p>
<p>現在將移至 <code>src/lib.rs</code> 的程式碼引入二進制 <code>crate</code> 的 <code>src/main.rs</code> 作用域中。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;解析引數時出現問題：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;搜尋 &#123;&#125;&quot;</span>, config.query);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;目標檔案為 &#123;&#125;&quot;</span>, config.filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;應用程式錯誤：&#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在所有的功能都應該正常。透過 <code>cargo run</code> 來執行程式並確保一切正常。</p>
<h2 id="完善功能"><a href="#完善功能" class="headerlink" title="完善功能"></a>完善功能</h2><p>以下會在 <code>minigrep</code> 程式中利用試驅動開發（Test-driven development, TDD）來新增搜尋邏輯。此程式開發技巧遵循以下步驟：</p>
<ol>
<li>寫出一個會失敗的測試並執行它來確保它失敗的原因如你所預期。</li>
<li>寫出或修改足夠的程式碼來讓新測試可以通過。</li>
<li>重構你新增或變更的程式碼並確保測試仍能持續通過。</li>
<li>重複第一步！</li>
</ol>
<h3 id="編寫失敗的測試"><a href="#編寫失敗的測試" class="headerlink" title="編寫失敗的測試"></a>編寫失敗的測試</h3><p>修改 <code>src/lib.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">one_result</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此測試搜尋字串 <code>&quot;duct&quot;</code>。而要被搜尋的文字有三行，只有一行包含 <code>&quot;duct&quot;</code>（在雙引號開頭後方的斜線會告訴 Rust 別在此字串內容開始處換行）。我們判定 <code>search</code> 函式回傳的數值只會包含我們預期的那一行。</p>
<p>我們還無法執行此程式並觀察其失敗，因為測試還無法編譯，<code>search</code> 函式根本還不存在！所以現在我們要加上足夠的程式碼讓測試可以編譯並執行，而我們要加上的是 <code>search</code> 函式的定義並永遠回傳一個空的向量，如下所示。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">vec!</span>[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是在 <code>search</code> 的簽名中需要定義一個顯式的生命週期 <code>&#39;a</code>，並用於 <code>contents</code> 引數與回傳值。生命週期參數會連結引數生命週期與回傳值生命週期。在此例中，我們指明回傳值應包含字串切片且其會引用 <code>contents</code> 引數的切片（而非引數 <code>query</code>）。</p>
<p>換句話說，我們告訴 Rust，<code>search</code> 函式回傳的資料會跟傳遞給 <code>search</code> 函式的引數 <code>contents</code> 資料存活得一樣久。這點很重要！被切片引用的資料必須有效，這樣其引用才會有效。如果編譯器假設是在建立 <code>query</code> 而非 <code>contents</code> 的字串切片，它的安全檢查就會不正確。</p>
<p>由於引數 <code>contents</code> 包含所有文字且我們想要回傳符合條件的部分文字，所以我們知道 <code>contents</code> 引數要用生命週期語法與回傳值做連結。其他程式設計語言不會要求你要在簽名中連結引數與回傳值。</p>
<h3 id="寫出讓測試成功的程式碼"><a href="#寫出讓測試成功的程式碼" class="headerlink" title="寫出讓測試成功的程式碼"></a>寫出讓測試成功的程式碼</h3><p>目前我們的測試會失敗，因為我們永遠只回傳一個空向量。要修正並實作 <code>search</code>，我們的程式需要完成以下步驟：</p>
<ul>
<li>遍歷內容的每一行。</li>
<li>檢查該行是否包含我們要搜尋的字串。</li>
<li>如果有的話，將它加入我們要回傳的數值列表。</li>
<li>如果沒有的話，不做任何事。</li>
<li>回傳符合的結果列表。</li>
</ul>
<h4 id="透過-lines-方法來遍歷每一行"><a href="#透過-lines-方法來遍歷每一行" class="headerlink" title="透過 lines 方法來遍歷每一行"></a>透過 <code>lines</code> 方法來遍歷每一行</h4><p>Rust 有個實用的方法能逐步處理字串的每一行，這方法就叫 <code>lines</code>，<code>lines</code> 方法會回傳疊代器（iterator）。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="檢查每行是否有要搜尋的字串"><a href="#檢查每行是否有要搜尋的字串" class="headerlink" title="檢查每行是否有要搜尋的字串"></a>檢查每行是否有要搜尋的字串</h4><p>我們要檢查目前的行是否有包含我們要搜尋的字串。幸運的是，字串有個好用的方法叫做 <code>contains</code> 能幫我處理這件事。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="儲存符合條件的行"><a href="#儲存符合條件的行" class="headerlink" title="儲存符合條件的行"></a>儲存符合條件的行</h4><p>需要有個方式能儲存包含搜尋字串的行。為此我們可以在 <code>for</code> 迴圈前建立一個可變向量然後對向量呼叫 <code>push</code> 方法來儲存 <code>line</code>。在 <code>for</code> 迴圈之後，我們回傳向量。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在 <code>search</code> 函式應該只會回傳包含 <code>query</code> 的行，而測試也該通過。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h4 id="在-run-函式中使用-search-函式"><a href="#在-run-函式中使用-search-函式" class="headerlink" title="在 run 函式中使用 search 函式"></a>在 <code>run</code> 函式中使用 <code>search</code> 函式</h4><p>修改 <code>src/lib.rs</code> 檔。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行程式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cargo run frog poem.txt</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.38s</span><br><span class="line">     Running `target/debug/minigrep frog poem.txt`</span><br><span class="line">How public, like a frog</span><br></pre></td></tr></table></figure>

<p>最後，讓我們確保使用詩中沒出現的單字來搜尋時，我們不會得到任何一行，像是「monomorphization」：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cargo run monomorphization poem.txt</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/minigrep monomorphization poem.txt`</span><br></pre></td></tr></table></figure>

<h2 id="處理環境變數"><a href="#處理環境變數" class="headerlink" title="處理環境變數"></a>處理環境變數</h2><p>使用者可以透過環境變數來啟用不區分大小寫的搜尋功能。</p>
<h3 id="寫個不區分大小寫的-search-函式的失敗測試"><a href="#寫個不區分大小寫的-search-函式的失敗測試" class="headerlink" title="寫個不區分大小寫的 search 函式的失敗測試"></a>寫個不區分大小寫的 <code>search</code> 函式的失敗測試</h3><p>新增一個 <code>search_case_insensitive</code> 函式在環境變數啟用時呼叫它。並將舊測試從 <code>one_result</code> 改名為 <code>case_sensitive</code> 以便清楚兩個測試的差別。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Duct tape.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe, fast, productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;rUsT&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe, fast, productive.</span></span><br><span class="line"><span class="string">Pick three.</span></span><br><span class="line"><span class="string">Trust me.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;Rust:&quot;</span>, <span class="string">&quot;Trust me.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行測試。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="實作-search-case-insensitive-函式"><a href="#實作-search-case-insensitive-函式" class="headerlink" title="實作 search_case_insensitive 函式"></a>實作 <code>search_case_insensitive</code> 函式</h3><p>與 <code>search</code> 函式幾乎一樣。唯一的不同在於我們將 <code>query</code> 與每個 <code>line</code> 都變成小寫，所以無論輸入引數是大寫還是小寫，當我們在檢查行是否包含搜尋的字串時，它們都會是小寫。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            results.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在當我們將 <code>query</code> 作為引數傳給 <code>contains</code> 方法時，我們需要加上「<code>&amp;</code>」，因為 <code>contains</code> 所定義的簽名接收的是一個字串切片。</p>
<p>接著，在我們檢查是否包含小寫的 <code>query</code> 前，我們對每個 <code>line</code> 加上 <code>to_lowercase</code> 的呼叫。現在我們將 <code>line</code> 和 <code>query</code> 都轉換成小寫了。我們可以不區分大小寫來找到符合的行。</p>
<p>執行測試。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>現在讓我們從 <code>run</code> 函式呼叫新的 <code>search_case_insensitive</code> 函式。首先，我們要在 <code>Config</code> 中新增一個配置選項來切換區分大小寫與不區分大小寫之間的搜尋。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著，我們需要 <code>run</code> 函式檢查 <code>case_sensitive</code> 欄位的數值，並以此決定要呼叫 <code>search</code> 函式或是 <code>search_case_insensitive</code> 函式。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(config.filename)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後，我們需要檢查環境變數。處理環境變數的函式位於標準函式庫中的 <code>env</code> 模組中，所以我們可以在 <code>src/lib.rs</code> 檔最上方加上 <code>use std::env;</code> 來將該模組引入作用域。然後我們使用 <code>env</code> 模組中的 <code>var</code> 函式來檢查一個叫做 <code>CASE_INSENSITIVE</code> 的環境變數。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;引數不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們在 <code>Result</code> 使用 <code>is_err</code> 方法來檢查是否為錯誤，如果是的話就代表沒有設置，也意味著它該使用區分大小寫的搜尋。如果 <code>CASE_INSENSITIVE</code> 環境變數有設置成任何數值的話，<code>is_err</code> 會回傳否，所以程式就會進行不區分大小寫的搜尋。我們不在乎環境變數的數值，只在意它有沒有被設置而已，所以我們使用 <code>is_err</code> 來檢查而非使用 <code>unwrap</code>、<code>expect</code> 或其他任何我們看過的 <code>Result</code> 方法。</p>
<p>首先，我們先不設置環境變數並執行程式來搜尋「to」，任何包含小寫單字「to」的行都應要符合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cargo run to poem.txt</span><br><span class="line">   Compiling minigrep v0.1.0 (file:///projects/minigrep)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/minigrep to poem.txt`</span><br><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p>現在，設置 <code>CASE_INSENSITIVE</code> 為 <code>1</code>，並執行程式來搜尋相同的字串「to」。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE_INSENSITIVE=1 cargo run to poem.txt</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/minigrep to poem.txt`</span><br><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br><span class="line">To tell your name the livelong day</span><br><span class="line">To an admiring bog!</span><br></pre></td></tr></table></figure>

<p>現在 <code>minigrep</code> 程式現在可以進行不區分大小寫的搜尋並以環境變數配置。</p>
<h2 id="處理標準錯誤"><a href="#處理標準錯誤" class="headerlink" title="處理標準錯誤"></a>處理標準錯誤</h2><p>目前我們使用 <code>println!</code> 巨集來將所有的輸出顯示到終端機。大多數的終端機都提供兩種輸出方式：用於通用資訊的標準輸出（standard output, stdout）以及用於錯誤訊息的標準錯誤（standard error, stderr）。這樣的區別讓使用者可以選擇將程式的成功輸出導向到一個檔案中，並仍能在螢幕上顯示錯誤訊息。</p>
<p><code>println!</code> 巨集只能夠印出標準輸出，所以我們得用其他方式來印出標準錯誤。</p>
<h3 id="檢查該在哪裡寫錯誤"><a href="#檢查該在哪裡寫錯誤" class="headerlink" title="檢查該在哪裡寫錯誤"></a>檢查該在哪裡寫錯誤</h3><p>命令列程式應該要傳送錯誤訊息至標準錯誤，讓我們可以在重新導向標準輸出至檔案時，仍能在螢幕上看到錯誤訊息。</p>
<p>要觀察此行為的方式是透過 <code>&gt;</code> 來執行程式並加上檔案名稱 <code>output.txt</code>，這是我們要重新導向標準輸出到的地方。我們不會傳遞任何引數，這樣就應該會造成錯誤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>透過 <code>&gt;</code> 語法告訴 shell 要將標準輸出的內容寫入 <code>output.txt</code> 而不是顯示在螢幕上。但沒有看到應顯示在螢幕上的錯誤訊息，這代表它一定跑到檔案中了。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解析引數時出現問題：引數不足</span><br></pre></td></tr></table></figure>

<p>我們的錯誤訊息印到了標準輸出。像這樣的錯誤訊息印到標準錯誤會比較好，這樣才能只讓成功執行的資料存至檔案中。</p>
<h3 id="將錯誤印出至標準錯誤"><a href="#將錯誤印出至標準錯誤" class="headerlink" title="將錯誤印出至標準錯誤"></a>將錯誤印出至標準錯誤</h3><p>標準函式庫有提供 <code>eprintln!</code> 巨集來印到標準錯誤，所以讓我們變更兩個原本呼叫 println! 來印出錯誤的段落來改使用 <code>eprintln!</code>。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;解析引數時出現問題：&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config) &#123;</span><br><span class="line">        eprintln!(<span class="string">&quot;應用程式錯誤：&#123;&#125;&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以相同方式再執行程式一次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo run &gt; output.txt</span><br><span class="line">解析引數時出現問題：引數不足</span><br></pre></td></tr></table></figure>

<p>現在我們看到錯誤顯示在螢幕上而且 <code>output.txt</code> 裡什麼也沒只有，這正是命令列程式所預期的行為。</p>
<p>讓我們加上不會產生錯誤的引數來執行程式，並仍重新導向標準輸出至檔案中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run to poem.txt &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>在終端機不會看到任何輸出，而 <code>output.txt</code> 會包含我們的結果。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Are you nobody, too?</span><br><span class="line">How dreary to be somebody!</span><br></pre></td></tr></table></figure>

<p>這說明我們現在有對成功的輸出使用標準輸出，而且有妥善地將錯誤輸出傳至標準錯誤。</p>
<h2 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/memochou1993/minigrep">minigrep</a></li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Archives</a></li>
         
          <li><a href="/categories">Categories</a></li>
         
          <li><a href="/tags">Tags</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%A1%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">簡介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%97%E5%91%BD%E4%BB%A4%E5%88%97%E5%BC%95%E6%95%B8"><span class="toc-number">3.</span> <span class="toc-text">接受命令列引數</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E5%BC%95%E6%95%B8%E6%95%B8%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">讀取引數數值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E5%BC%95%E6%95%B8%E6%95%B8%E5%80%BC%E5%84%B2%E5%AD%98%E8%87%B3%E8%AE%8A%E6%95%B8"><span class="toc-number">3.2.</span> <span class="toc-text">將引數數值儲存至變數</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E6%AA%94%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">讀取檔案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%A7%8B"><span class="toc-number">5.</span> <span class="toc-text">重構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%96%8B%E4%BA%8C%E9%80%B2%E5%88%B6%E5%B0%88%E6%A1%88%E7%9A%84%E4%BB%BB%E5%8B%99"><span class="toc-number">5.1.</span> <span class="toc-text">分開二進制專案的任務</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%BC%95%E6%95%B8%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">提取引數解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%B5%90%E9%85%8D%E7%BD%AE%E6%95%B8%E5%80%BC"><span class="toc-number">5.1.2.</span> <span class="toc-text">集結配置數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-Config-%E7%9A%84%E5%BB%BA%E6%A7%8B%E5%AD%90"><span class="toc-number">5.1.3.</span> <span class="toc-text">建立 Config 的建構子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">修正錯誤處理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E5%96%84%E9%8C%AF%E8%AA%A4%E8%A8%8A%E6%81%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">改善錯誤訊息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%82%B3-Result-%E8%80%8C%E9%9D%9E%E6%81%90%E6%85%8C"><span class="toc-number">5.2.2.</span> <span class="toc-text">回傳 Result 而非恐慌</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BC%E5%8F%AB-Config-new-%E4%B8%A6%E8%99%95%E7%90%86%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.2.3.</span> <span class="toc-text">呼叫 Config::new 並處理錯誤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-main-%E9%82%8F%E8%BC%AF"><span class="toc-number">5.3.</span> <span class="toc-text">提取 main 邏輯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%9E-run-%E5%87%BD%E5%BC%8F%E5%9B%9E%E5%82%B3%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.4.</span> <span class="toc-text">從 run 函式回傳錯誤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%95%E7%90%86-run-%E5%9B%9E%E5%82%B3%E7%9A%84%E9%8C%AF%E8%AA%A4"><span class="toc-number">5.4.1.</span> <span class="toc-text">處理 run 回傳的錯誤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%8B%86%E5%88%B0%E5%87%BD%E5%BC%8F%E5%BA%AB-Crate"><span class="toc-number">5.5.</span> <span class="toc-text">將程式碼拆到函式庫 Crate</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%96%84%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">完善功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B7%A8%E5%AF%AB%E5%A4%B1%E6%95%97%E7%9A%84%E6%B8%AC%E8%A9%A6"><span class="toc-number">6.1.</span> <span class="toc-text">編寫失敗的測試</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%AB%E5%87%BA%E8%AE%93%E6%B8%AC%E8%A9%A6%E6%88%90%E5%8A%9F%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="toc-number">6.2.</span> <span class="toc-text">寫出讓測試成功的程式碼</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E9%81%8E-lines-%E6%96%B9%E6%B3%95%E4%BE%86%E9%81%8D%E6%AD%B7%E6%AF%8F%E4%B8%80%E8%A1%8C"><span class="toc-number">6.2.1.</span> <span class="toc-text">透過 lines 方法來遍歷每一行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AA%A2%E6%9F%A5%E6%AF%8F%E8%A1%8C%E6%98%AF%E5%90%A6%E6%9C%89%E8%A6%81%E6%90%9C%E5%B0%8B%E7%9A%84%E5%AD%97%E4%B8%B2"><span class="toc-number">6.2.2.</span> <span class="toc-text">檢查每行是否有要搜尋的字串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%84%B2%E5%AD%98%E7%AC%A6%E5%90%88%E6%A2%9D%E4%BB%B6%E7%9A%84%E8%A1%8C"><span class="toc-number">6.2.3.</span> <span class="toc-text">儲存符合條件的行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-run-%E5%87%BD%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8-search-%E5%87%BD%E5%BC%8F"><span class="toc-number">6.2.4.</span> <span class="toc-text">在 run 函式中使用 search 函式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%95%E7%90%86%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8"><span class="toc-number">7.</span> <span class="toc-text">處理環境變數</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%AB%E5%80%8B%E4%B8%8D%E5%8D%80%E5%88%86%E5%A4%A7%E5%B0%8F%E5%AF%AB%E7%9A%84-search-%E5%87%BD%E5%BC%8F%E7%9A%84%E5%A4%B1%E6%95%97%E6%B8%AC%E8%A9%A6"><span class="toc-number">7.1.</span> <span class="toc-text">寫個不區分大小寫的 search 函式的失敗測試</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%A6%E4%BD%9C-search-case-insensitive-%E5%87%BD%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">實作 search_case_insensitive 函式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%95%E7%90%86%E6%A8%99%E6%BA%96%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.</span> <span class="toc-text">處理標準錯誤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AA%A2%E6%9F%A5%E8%A9%B2%E5%9C%A8%E5%93%AA%E8%A3%A1%E5%AF%AB%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.1.</span> <span class="toc-text">檢查該在哪裡寫錯誤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%87%E9%8C%AF%E8%AA%A4%E5%8D%B0%E5%87%BA%E8%87%B3%E6%A8%99%E6%BA%96%E9%8C%AF%E8%AA%A4"><span class="toc-number">8.2.</span> <span class="toc-text">將錯誤印出至標準錯誤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BC%8F%E7%A2%BC"><span class="toc-number">9.</span> <span class="toc-text">程式碼</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="toc-number">10.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&text=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&is_video=false&description=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=「The Rust Programming Language」學習筆記（十二）：建立命令列程式&body=Check out this article: https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&title=「The Rust Programming Language」學習筆記（十二）：建立命令列程式"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.epoch.tw/2022/09/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%91%BD%E4%BB%A4%E5%88%97%E7%A8%8B%E5%BC%8F/&name=「The Rust Programming Language」學習筆記（十二）：建立命令列程式&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2024 Memo Chou
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Archives</a></li>
         
          <li><a href="/categories">Categories</a></li>
         
          <li><a href="/tags">Tags</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8MBP8ZTMCR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-8MBP8ZTMCR');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'https-memochou1993-github-io-blog';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- Mermaid chart -->

    <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>

<!-- Google AdSense -->

   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1523667193708406" crossorigin="anonymous"></script>

