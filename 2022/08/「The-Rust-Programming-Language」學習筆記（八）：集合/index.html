<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta name="author" content="Memo Chou">
    <meta name="description" content="Memo's Blog">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="前言本文為「The Rust Programming Language」語言指南的學習筆記。 簡介Rust 的標準函式庫提供一些非常實用的資料結構稱之為集合（collections）。多數其他資料型別只會呈現一個特定數值，但是集合可以包含數個數值。不像內建的陣列與元組型別，這些集合指向的資料位於堆積上，代表資料的數量不必在編譯期就知道，而且可以隨著程式執行增長或縮減。 以下三種是在 Rust 程式">
<meta property="og:type" content="article">
<meta property="og:title" content="「The Rust Programming Language」學習筆記（八）：集合">
<meta property="og:url" content="https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Memo&#39;s Blog">
<meta property="og:description" content="前言本文為「The Rust Programming Language」語言指南的學習筆記。 簡介Rust 的標準函式庫提供一些非常實用的資料結構稱之為集合（collections）。多數其他資料型別只會呈現一個特定數值，但是集合可以包含數個數值。不像內建的陣列與元組型別，這些集合指向的資料位於堆積上，代表資料的數量不必在編譯期就知道，而且可以隨著程式執行增長或縮減。 以下三種是在 Rust 程式">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-06T14:45:36.000Z">
<meta property="article:modified_time" content="2023-11-30T03:05:47.729Z">
<meta property="article:author" content="Memo Chou">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>「The Rust Programming Language」學習筆記（八）：集合</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100;300;400;500;700;900&family=Raleway:wght@900&display=swap" rel="stylesheet">
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Memo's Blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        
          
            <li><a href="/">Home</a></li>
          
        
          
            <li><a href="/archives">Articles</a></li>
          
        
          
        
          
        
          
            <li><a href="/search">Search</a></li>
          
        
          
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/08/%E4%BD%BF%E7%94%A8-Helm-%E6%90%AD%E5%BB%BA-Metabase-%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/08/%E4%BD%BF%E7%94%A8-Rust-%E5%BB%BA%E7%AB%8B%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92%E4%BC%BA%E6%9C%8D%E5%99%A8/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <!-- <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li> -->
      </ul>
      <!-- <span id="i-next" class="info" style="display:none;"></span>
      <span id="i-prev" class="info" style="display:none;"></span>
      <span id="i-top" class="info" style="display:none;"></span>
      <span id="i-share" class="info" style="display:none;"></span> -->
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&text=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&is_video=false&description=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=「The Rust Programming Language」學習筆記（八）：集合&body=Check out this article: https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&name=「The Rust Programming Language」學習筆記（八）：集合&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%A1%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">簡介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%90%91%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">建立向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%90%91%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">更新向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8B%E6%94%BE%E5%90%91%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">釋放向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E5%90%91%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">讀取向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E6%AD%B7%E5%90%91%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">遍歷向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E8%88%89%E4%BE%86%E5%84%B2%E5%AD%98%E5%A4%9A%E7%A8%AE%E5%9E%8B%E5%88%A5"><span class="toc-number">3.6.</span> <span class="toc-text">使用枚舉來儲存多種型別</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">字串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%BE%A9"><span class="toc-number">4.1.</span> <span class="toc-text">定義</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%AD%97%E4%B8%B2"><span class="toc-number">4.2.</span> <span class="toc-text">建立字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E4%B8%B2"><span class="toc-number">4.3.</span> <span class="toc-text">更新字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%97%E4%B8%B2"><span class="toc-number">4.4.</span> <span class="toc-text">索引字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">4.5.</span> <span class="toc-text">字串切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E6%AD%B7%E5%AD%97%E4%B8%B2"><span class="toc-number">4.6.</span> <span class="toc-text">遍歷字串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">雜湊映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.1.</span> <span class="toc-text">建立雜湊映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84%E8%88%87%E6%89%80%E6%9C%89%E6%AC%8A"><span class="toc-number">5.2.</span> <span class="toc-text">雜湊映射與所有權</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.3.</span> <span class="toc-text">讀取雜湊映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.4.</span> <span class="toc-text">更新雜湊映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E8%93%8B%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.1.</span> <span class="toc-text">覆蓋數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E9%8D%B5%E6%B2%92%E6%9C%89%E5%80%BC%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%E6%8F%92%E5%85%A5%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.2.</span> <span class="toc-text">只在鍵沒有值的情況下插入數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%93%9A%E8%88%8A%E5%80%BC%E6%9B%B4%E6%96%B0%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.3.</span> <span class="toc-text">依據舊值更新數值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E5%87%BD%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">雜湊函式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index my4">
        
        <article class="post my2" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        「The Rust Programming Language」學習筆記（八）：集合
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">
          <a href="/">
          Memo's Blog
          </a>
        </span>
      </span>
      
    <div class="postdate">
        <time datetime="2022-08-06T14:45:36.000Z" itemprop="datePublished">2022-08-06</time>
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        
            
        
            
        
            
                <a href="/categories/Programming/Rust/%E3%80%8CThe-Rust-Programming-Language%E3%80%8DStudy-Notes/">「The Rust Programming Language」Study Notes</a>
            
        
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Programming/" rel="tag">Programming</a>, <a class="tag-link-link" href="/tags/Rust/" rel="tag">Rust</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文為「<a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a>」語言指南的學習筆記。</p>
<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>Rust 的標準函式庫提供一些非常實用的資料結構稱之為集合（collections）。多數其他資料型別只會呈現一個特定數值，但是集合可以包含數個數值。不像內建的陣列與元組型別，這些集合指向的資料位於堆積上，代表資料的數量不必在編譯期就知道，而且可以隨著程式執行增長或縮減。</p>
<p>以下三種是在 Rust 程式中十分常用的集合：</p>
<ul>
<li>向量（Vector）：允許儲存數量不定的數值。</li>
<li>字串（String）：是字元的集合。</li>
<li>雜湊映射（Hash map）：允許將值（value）與特定的鍵（key）相關聯。這是從一種更通用的資料結構映射（map）衍生出來的特定實作。</li>
</ul>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><h3 id="建立向量"><a href="#建立向量" class="headerlink" title="建立向量"></a>建立向量</h3><p>集合 <code>Vec&lt;T&gt;</code> 常稱為向量（vector），允許在一個資料結構儲存不止一個數值，而且該結構的記憶體會接連排列所有數值。</p>
<p>要建立一個新的空向量的話，我們呼叫 <code>Vec::new</code> 函式。標準函式庫提供的 <code>Vec&lt;T&gt;</code> 型別可以持有任意型別，然後當特定向量要持有特定型別時，我們可以在尖括號內指定該型別。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>Rust 還提供了 <code>vec!</code> 巨集讓我們能方便地建立一個新的向量並取得提供的數值。以下建立了一個新的 <code>Vec&lt;i32&gt;</code>，並擁有數值 1、2 和 3。整數型別為 <code>i32</code> 是因為這是預設整數型別。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="更新向量"><a href="#更新向量" class="headerlink" title="更新向量"></a>更新向量</h3><p>要在建立向量之後新增元素的話，可以使用 <code>push</code> 方法。與其他變數一樣，如果想要變更其數值的話，需要使用 <code>mut</code> 關鍵字使它成為可變的。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">7</span>);</span><br></pre></td></tr></table></figure>

<h3 id="釋放向量"><a href="#釋放向量" class="headerlink" title="釋放向量"></a>釋放向量</h3><p>就像其它 <code>struct</code> 一樣，向量會在作用域結束時被釋放。當向量被釋放時，其所有內容也都會被釋放，代表它持有的那些整數都會被清除。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 使用 v 做些事情</span></span><br><span class="line">&#125; <span class="comment">// &lt;- v 在此離開作用域並釋放</span></span><br></pre></td></tr></table></figure>

<h3 id="讀取向量"><a href="#讀取向量" class="headerlink" title="讀取向量"></a>讀取向量</h3><p>取得向量中數值的方法，可以使用索引語法與 <code>get</code> 方法。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第三個元素為 &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(v) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三個元素為 &#123;&#125;&quot;</span>, v),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三個元素並不存在。&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 提供兩種取得元素引用方式，第一個 <code>[]</code> 方法會讓程式恐慌，因為它引用了不存在的元素。此方法適用於當你希望一有無效索引時就讓程式崩潰的狀況。當使用 <code>get</code> 方法來索取向量不存在的索引時，它會回傳 <code>None</code> 而不會恐慌。如果正常情況下偶而會不小心存取超出向量範圍索引的話，就會想要只用此方法。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = &amp;v[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">does_not_exist</span> = v.<span class="title function_ invoke__">get</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>有個規則是我們不能在同個作用域同時擁有可變與不可變引用。在此我們有一個向量第一個元素的不可變引用，然後我們嘗試在向量後方新增元素。如果我們嘗試在此動作後繼續使用第一個引用的話，程式會無法執行。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;第一個元素為 &#123;&#125;&quot;</span>, first);</span><br></pre></td></tr></table></figure>

<p>為何第一個元素的引用要在意向量的最後端發生了什麼事呢？此錯誤其實跟向量運作的方式有關：由於向量會將元素放在前一位的記憶體位置後方，在向量後方新增元素時，如果當前向量的空間不夠在塞入另一個值的話，可能會需要分配新的記憶體並複製舊的元素到新的空間中。這樣一來，第一個元素的索引可能就會指向已經被釋放的記憶體，借用規則會防止程式遇到這樣的情形。</p>
<h3 id="遍歷向量"><a href="#遍歷向量" class="headerlink" title="遍歷向量"></a>遍歷向量</h3><p>想要依序存取向量中每個元素的話，我們可以遍歷所有元素而不必用索引一個一個取得。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>還可以遍歷可變向量中的每個元素取得可變引用來改變每個元素。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">    *i += <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用枚舉來儲存多種型別"><a href="#使用枚舉來儲存多種型別" class="headerlink" title="使用枚舉來儲存多種型別"></a>使用枚舉來儲存多種型別</h3><p>向量只能儲存同型別的數值，這在某些情況會很不方便，一定會有場合是要儲存不同型別到一個列表中。幸運的是，枚舉的變體是定義在相同的枚舉型別，所以當我們需要在向量儲存不同型別的元素時，我們可以用枚舉來定義。</p>
<p>舉例來說，假設我們想從表格中的一行取得數值，但是有些行內的列會包含整數、浮點數以及一些字串。我們可以定義一個枚舉，其變體會持有不同的數值型別，然後所有的枚舉變體都會被視為相同型別：就是它們的枚舉。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍色&quot;</span>)),</span><br><span class="line">    SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>Rust 需要在編譯時期知道向量的型別以及要在堆積上用到多少記憶體才能儲存每個元素。我們必須明確知道哪些型別可以放入向量中。如果 Rust 允許向量一次持有任意型別的話，在對向量中每個元素進行處理時，可能就會有一或多種型別會產生錯誤。使用枚舉和 <code>match</code> 表達式讓 Rust 可以在編譯期間確保每個可能的情形都已經處理完善了。</p>
<h2 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h2><h3 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h3><p>Rust 在核心語言中只有一個字串型別，那就是字串切片 <code>str</code>，它通常是以借用的形式存在 <code>&amp;str</code>。字串切片是一個針對存在某處的 UTF-8 編碼資料的引用。舉例來說，字串字面值（String literals）就儲存在程式的二進制檔案中，因此就是字串切片。</p>
<p><code>String</code> 型別是 Rust 標準函式庫所提供的型別，並不是核心語言內建的型別，它是可增長的、可變的、可擁有所有權的 UTF-8 編碼字串型別。當 Rustaceans 提及 Rust 中的「字串」時，他們通常指的是 <code>String</code> 以及字串切片 <code>&amp;str</code> 型別，而不只是其中一種型別。</p>
<p>Rust 的標準函式庫還包含了其他種類的字串型別，像是 <code>OsString</code>、<code>OsStr</code>、<code>CString</code> 以及 <code>CStr</code>。函式庫 crates 更可以提供儲存字串資料的更多選項。注意到這些型別的結尾都是 <code>String</code> 和 <code>Str</code>，它們分別代表擁有所有權與借用的變體。這些字串型別可以儲存不同編碼的文字或者以不同的記憶體形式呈現。</p>
<h3 id="建立字串"><a href="#建立字串" class="headerlink" title="建立字串"></a>建立字串</h3><p>許多 <code>Vec&lt;T&gt;</code> 可使用的方法在 <code>String</code> 也都能用，像是用 <code>new</code> 函式建立新的字串。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure>

<p>通常我們會希望建立字串的同時能夠初始化資料，為此我們可以使用 <code>to_string</code> 方法，任何有實作 <code>Display</code> 特徵的型別都可以使用此方法，就像字串字面值的使用方式一樣。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;初始內容&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法也能直接用於字面值上</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;初始內容&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>我們也可以用函式 <code>String::from</code> 從字串字面值建立 String。和使用 <code>to_string</code> 的效果一樣。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;初始內容&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的範例中 <code>String::from</code> 和 <code>to_string</code> 都在做相同的事，所以選擇跟喜好風格與閱讀性比較有關。</p>
<p>字串是 UTF-8 編碼的，所以我們可以包含任何正確編碼的資料。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hola&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="更新字串"><a href="#更新字串" class="headerlink" title="更新字串"></a>更新字串</h3><p>可以使用 <code>push_str</code> 方法來追加一個字串切片使字串增長。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="comment">// foobar</span></span><br></pre></td></tr></table></figure>

<p>而 <code>push</code> 方法會取得一個字元作為參數並加到 <code>String</code> 上。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="comment">// lol</span></span><br></pre></td></tr></table></figure>

<p>通常會想要組合兩個字串在一起，其中一種方式是用 <code>+</code> 運算子。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意到 s1 被移動因此無法再被使用</span></span><br></pre></td></tr></table></figure>

<p>雖然 <code>let s3 = s1 + &amp;s2;</code> 看起來像是它拷貝了兩個字串的值並產生了一個新的，但此陳述式實際上是取得 <code>s1</code> 的所有權、追加一份 <code>s2</code> 的複製內容，然後回傳最終結果的所有權。</p>
<p>如果要完成更複雜的字串組合的話，我們可以改使用 <code>format!</code> 巨集：</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br><span class="line"><span class="comment">// tic-tac-toe</span></span><br></pre></td></tr></table></figure>

<p><code>format!</code> 巨集運作的方式和 <code>println!</code> 類似，但不會將輸出結果顯示在螢幕上，它做的是回傳內容的 <code>String</code>。使用 <code>format!</code> 的程式碼版本看起來比較好讀懂，而且 <code>format!</code> 產生的程式碼使用的是引用，所以此呼叫不會取走任何參數的所有權。</p>
<h3 id="索引字串"><a href="#索引字串" class="headerlink" title="索引字串"></a>索引字串</h3><p>Rust 字串並不支援索引。</p>
<p>將「Здравствуйте」用 UTF-8 編碼後的位元組長度，因為該字串的每個 Unicode 純量都佔據兩個位元組。因此字串位元組的索引不會永遠都能對應到有效的 Unicode 純量數值。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Rust 還有一個不允許索引 <code>String</code> 來取得字元的原因是因為，索引運算必須永遠預期是花費常數時間（<code>O(1)</code>）。但在 <code>String</code> 上無法提供這樣的效能保證，因為 Rust 會需要從索引的開頭遍歷每個內容才能決定多少有效字元存在。</p>
<h3 id="字串切片"><a href="#字串切片" class="headerlink" title="字串切片"></a>字串切片</h3><p>與其在 <code>[]</code> 只使用一個數字來索引，你可以在 <code>[]</code> 指定一個範圍來建立包含特定位元組的字串切片。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>使用範圍來建立字串切片時要格外小心，因為這樣做有可能會使你的程式崩潰。</p>
<h3 id="遍歷字串"><a href="#遍歷字串" class="headerlink" title="遍歷字串"></a>遍歷字串</h3><p>要對字串的部分進行操作最好的方式是明確表達想要的是字元還是位元組。對獨立的 Unicode 純量型別來說的話，就是使用 <code>chars</code> 方法。對「नमस्ते」呼叫 <code>chars</code> 會將六個擁有 <code>char</code> 型別的數值拆開並回傳，這樣一來就可以遍歷每個元素。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼會顯示以下輸出：</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure>

<p>而 <code>bytes</code> 方法會回傳每個原始位元組。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼會印出此 <code>String</code> 的 18 個位元組。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">224</span></span><br><span class="line"><span class="number">164</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="number">165</span></span><br><span class="line"><span class="number">135</span></span><br></pre></td></tr></table></figure>

<p>需要了解，有效的 Unicode 純量數值可能不止佔 1 個位元組。</p>
<h2 id="雜湊映射"><a href="#雜湊映射" class="headerlink" title="雜湊映射"></a>雜湊映射</h2><p><code>HashMap&lt;K, V&gt;</code> 型別會儲存一個鍵（key）型別 <code>K</code> 對應到一個數值（value）型別 <code>V</code>。它透過雜湊函式（hashing function）來決定要將這些鍵與值放在記憶體何處。雜湊映射適合用於當不想像向量那樣用索引搜尋資料，而是透過一個可以為任意型別的鍵來搜尋的情況。</p>
<h3 id="建立雜湊映射"><a href="#建立雜湊映射" class="headerlink" title="建立雜湊映射"></a>建立雜湊映射</h3><p>一種建立空的雜湊映射的方式是使用 <code>new</code> 並透過 <code>insert</code> 加入新元素。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;黃隊&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>另一種建構雜湊映射的方式為使用疊代器並在一個元組組成的向量中使用 <code>collect</code> 方法，其中每個元組都包含一個鍵與值的配對。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;黃隊&quot;</span>)];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;_, _&gt; =</span><br><span class="line">teams.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure>

<h3 id="雜湊映射與所有權"><a href="#雜湊映射與所有權" class="headerlink" title="雜湊映射與所有權"></a>雜湊映射與所有權</h3><p>像是 <code>i32</code> 這種有實作 <code>Copy</code> 特徵的型別，其數值可以被拷貝進雜湊映射之中。但對於像是 <code>String</code> 這種擁有所有權的數值，則會被移動到雜湊映射，並且成為該數值新的擁有者。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"><span class="comment">// field_name 和 field_value 在這之後就不能使用了</span></span><br></pre></td></tr></table></figure>

<h3 id="讀取雜湊映射"><a href="#讀取雜湊映射" class="headerlink" title="讀取雜湊映射"></a>讀取雜湊映射</h3><p>可以透過 <code>get</code> 方法並提供鍵來取得其在雜湊映射對應的值。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;黃隊&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>for</code> 迴圈用類似的方式來遍歷雜湊映射中每個鍵值配對。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;黃隊&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新雜湊映射"><a href="#更新雜湊映射" class="headerlink" title="更新雜湊映射"></a>更新雜湊映射</h3><p>雖然鍵值配對的數量可以增加，但每個鍵同一時間就只能有一個對應的值而已。當想要改變雜湊映射的資料的話，必須決定如何處理當一個鍵已經有一個值的情況。</p>
<h4 id="覆蓋數值"><a href="#覆蓋數值" class="headerlink" title="覆蓋數值"></a>覆蓋數值</h4><p>如果我們在雜湊映射插入一個鍵值配對，然後又在相同鍵插入不同的數值的話，該鍵相對應的數值就會被取代。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="number">10</span>);</span><br><span class="line">scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;藍隊&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure>

<h4 id="只在鍵沒有值的情況下插入數值"><a href="#只在鍵沒有值的情況下插入數值" class="headerlink" title="只在鍵沒有值的情況下插入數值"></a>只在鍵沒有值的情況下插入數值</h4><p>通常檢查某個特定的鍵有沒有數值，如果沒有的話才插入數值是很常見的。雜湊映射提供了一個特別的 API 叫做 <code>entry</code> 讓你可以用想要檢查的鍵作為參數。<code>entry</code> 方法的回傳值是一個枚舉叫做 <code>Entry</code>，它代表了一個可能存在或不存在的數值。</p>
<h4 id="依據舊值更新數值"><a href="#依據舊值更新數值" class="headerlink" title="依據舊值更新數值"></a>依據舊值更新數值</h4><p>雜湊映射還有另一種常見的用法是，依照鍵的舊數值來更新它。舉例來說，以下展示了一支如何計算一些文字內每個單字各出現多少次的程式碼。我們使用雜湊映射，鍵為單字然後值為我們每次追蹤計算對應單字出現多少次的次數。如果我們是第一次看到該單字的話，我們插入數值 0。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">    *count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure>

<h3 id="雜湊函式"><a href="#雜湊函式" class="headerlink" title="雜湊函式"></a>雜湊函式</h3><p>HashMap 預設是使用一種叫做 SipHash 的雜湊函式（hashing function），這可以透過雜湊表（hash table）抵禦阻斷服務（Denial of Service, DoS）的攻擊。這並不是最快的雜湊演算法，但為了提升安全性而犧牲一點效能是值得的。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Articles</a></li>
         
          <li><a href="/categories">Categories</a></li>
         
          <li><a href="/tags">Tags</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B0%A1%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">簡介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">向量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%90%91%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">建立向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%90%91%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">更新向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8B%E6%94%BE%E5%90%91%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">釋放向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E5%90%91%E9%87%8F"><span class="toc-number">3.4.</span> <span class="toc-text">讀取向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E6%AD%B7%E5%90%91%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">遍歷向量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%9A%E8%88%89%E4%BE%86%E5%84%B2%E5%AD%98%E5%A4%9A%E7%A8%AE%E5%9E%8B%E5%88%A5"><span class="toc-number">3.6.</span> <span class="toc-text">使用枚舉來儲存多種型別</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">字串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%BE%A9"><span class="toc-number">4.1.</span> <span class="toc-text">定義</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%AD%97%E4%B8%B2"><span class="toc-number">4.2.</span> <span class="toc-text">建立字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E4%B8%B2"><span class="toc-number">4.3.</span> <span class="toc-text">更新字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%97%E4%B8%B2"><span class="toc-number">4.4.</span> <span class="toc-text">索引字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-number">4.5.</span> <span class="toc-text">字串切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E6%AD%B7%E5%AD%97%E4%B8%B2"><span class="toc-number">4.6.</span> <span class="toc-text">遍歷字串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">雜湊映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.1.</span> <span class="toc-text">建立雜湊映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84%E8%88%87%E6%89%80%E6%9C%89%E6%AC%8A"><span class="toc-number">5.2.</span> <span class="toc-text">雜湊映射與所有權</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%80%E5%8F%96%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.3.</span> <span class="toc-text">讀取雜湊映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%9B%9C%E6%B9%8A%E6%98%A0%E5%B0%84"><span class="toc-number">5.4.</span> <span class="toc-text">更新雜湊映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E8%93%8B%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.1.</span> <span class="toc-text">覆蓋數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E5%9C%A8%E9%8D%B5%E6%B2%92%E6%9C%89%E5%80%BC%E7%9A%84%E6%83%85%E6%B3%81%E4%B8%8B%E6%8F%92%E5%85%A5%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.2.</span> <span class="toc-text">只在鍵沒有值的情況下插入數值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%93%9A%E8%88%8A%E5%80%BC%E6%9B%B4%E6%96%B0%E6%95%B8%E5%80%BC"><span class="toc-number">5.4.3.</span> <span class="toc-text">依據舊值更新數值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%9C%E6%B9%8A%E5%87%BD%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">雜湊函式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&text=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&is_video=false&description=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=「The Rust Programming Language」學習筆記（八）：集合&body=Check out this article: https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&title=「The Rust Programming Language」學習筆記（八）：集合"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://blog.epoch.tw/2022/08/%E3%80%8CThe-Rust-Programming-Language%E3%80%8D%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E9%9B%86%E5%90%88/&name=「The Rust Programming Language」學習筆記（八）：集合&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2024 Memo Chou
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Articles</a></li>
         
          <li><a href="/categories">Categories</a></li>
         
          <li><a href="/tags">Tags</a></li>
         
          <li><a href="/search">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/fontawesome-all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8MBP8ZTMCR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-8MBP8ZTMCR');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'https-memochou1993-github-io-blog';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>

<!-- Mermaid chart -->

    <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>

<!-- Google AdSense -->

   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1523667193708406" crossorigin="anonymous"></script>

